#!/usr/bin/env bash

#: TITLE: crc-input
#: DATE: 2019-04-23
#: VERSION: 0.1.0
#: AUTHOR: "Alex Y" <aleksandryackovlev@yandex.ru>
#: DESCRIPTION: Functions for getting users' input

[[ $crcInputLoaded ]] && return

source ./crc-env
source ./crc-utils
source ./crc-output

required() {
  if [[ -z $1 ]]; then
    echo 'The field is required'
  fi
}

# DESCRIPTION: Shows a text prompt to a user
# USAGE: textInput [OPTIONS]
# OPTIONS: -p prompt - text for a prompt, default to "Input: "
#          -d value - default value
#          -v validator - a function or to validate an input
#          -c - clear canvas on show, defalut to false
textInput() {
  local text
  local prompt
  local defaultPrompt
  local defaultValue
  local validator
  local validationResult
  local invalidPrompt
  local opts

  text=
  prompt=
  defaultPrompt='Input'
  defaultValue=
  validator=
  clearCanvas=0
  opts=p:d:v:c

  while getopts $opts opt; do
    case $opt in
      p)
        prompt="${OPTARG:-$defaultPrompt}"
        ;;
      d)
        defaultValue="$OPTARG"
        ;;
      v)
        validator="$OPTARG"
        ;;
      c)
        clearCanvas=1
        ;;
      *)
        crc-utils die "$(crc-env misuseErrorCode)" "An unknown options is set for a text input"
        ;;
    esac
  done

  shift $((OPTIND - 1))

  if [[ -n $defaultValue ]]; then
    prompt="${prompt} (default = ${defaultValue})"
  fi

  if [[ $clearCanvas -eq 1 ]]; then
    clear
  fi

  if [[ -n $prompt ]]; then
    prompt="$prompt: "
    read -r -p "$prompt" text
  else 
    read -r text
  fi

  text="${text:-$defaultValue}"

  if [[ -n $validator ]]; then

    validationResult=$($validator "$text" 2> /dev/null)

    while [[ -n $validationResult ]]; do
      invalidPrompt="$(crc-output setFg red)$validationResult $(crc-output clearFormat)$prompt"

      if [[ $clearCanvas -eq 1 ]]; then
        clear
      fi

      read -r -p "$invalidPrompt" text

      text="${text:-$defaultValue}"
      validationResult=$($validator "$text")
    done
  fi

  echo "$text"
}

# DESCRIPTION: Shows a select menu
# USAGE: selectInput [OPTIONS]
# OPTIONS: -p prompt - text for a prompt, default to "Select: "
#          -C - clear canvas on show, defalut to true
selectInput() {
  local max
  local activeItem
  local menuNum
  local description
  local value
  local k1
  local k2
  local k3
  local opts
  local defaultPrompt
  local prompt

  max=$#
  input=
  prompt=
  activeItem=1
  defaultPrompt='Select: '
  clearCanvas=1
  opts=p:C

  while getopts $opts opt; do
    case $opt in
      p)
        prompt="${OPTARG:-$defaultPrompt}"
        ;;
      C)
        clearCanvas=0
        ;;
      *)
        crc-utils die "$(crc-env misuseErrorCode)" "An unknown options is set for a select input"
        ;;
    esac
  done

  shift $((OPTIND - 1))

  while true; do
    if [[ $clearCanvas -eq 1 ]]; then
      clear
    fi

    crc-output setBold
    printf "%s\n" "$prompt"
    crc-output clearFormat
    crc-output hideCursor

    menuNum=1

    for item; do
      description="${item#*:}"

      if [[ $activeItem -eq "$menuNum" ]]; then
        crc-output setFg green
      else
        crc-output clearFormat
      fi

      printf "%${#max}d: %s\n" "$menuNum" "$description" >&1

      menuNum=$(( menuNum + 1))
    done

    crc-output clearFormat

    read -sn1 value

    if [[ $value = $'\e' ]]; then
      read -sN1 -t 0.0001 k1
      read -sN1 -t 0.0001 k2
      read -sN1 -t 0.0001 k3

      value=${value}${k1}${k2}${k3}
    fi

    case "$value" in
      k|$'\e[A'|$'\e0A')  # cursor up: previous item
        if [[ $activeItem -gt 1 ]]; then
          activeItem=$(( activeItem -1 ))
        fi
        ;;

      j|$'\e[B'|$'\e0B')  # cursor down: next item
        if [[ $activeItem -lt $max ]]; then
          activeItem=$(( activeItem + 1 ))
        fi
        ;;

      $'\e[1~'|$'\e0H'|$'\e[H')  # home: first item
        activeItem=1
        ;;

      $'\e[4~'|$'\e0F'|$'\e[F')  # end: last item
        activeItem="$max"
        ;;

      q|'') # q, carriage return: quit
        # TODO: Is there any other way to get the value from a subshell?
        input="${!activeItem%%:*}"
        crc-output showCursor
        return
        ;;
    esac 
  done
}

# DESCRIPTION: Shows a radio menu
# USAGE: radioInput [OPTIONS]
# OPTIONS: -p prompt - text for a prompt, default to "Select (y/n): "
#          -c - clear canvas on show, defalut to false
radioInput() {
  local text
  local prompt
  local defaultPrompt
  local invalidPrompt
  local opts

  text=
  prompt=
  defaultPrompt='Select'
  clearCanvas=0
  opts=p:c

  while getopts $opts opt; do
    case $opt in
      p)
        prompt="${OPTARG:-$defaultPrompt}"
        ;;
      c)
        clearCanvas=1
        ;;
      *)
        crc-utils die "$(crc-env misuseErrorCode)" "An unknown options is set for a radio input"
        ;;
    esac
  done

  shift $((OPTIND - 1))

  if [[ $clearCanvas -eq 1 ]]; then
    clear
  fi

  if [[ -n $prompt ]]; then
    prompt="$prompt (y/n): "
    read -r -sn1 -p "$prompt" text
  else 
    read -r -sn1 text
  fi

  validationResult=
  case $text in
    y|Y|n|N)
      ;;
    *)
      validationResult="Invalid value"
      ;;
  esac

  while [[ -n $validationResult ]]; do
    invalidPrompt="$(crc-output setFg red)$validationResult $(crc-output clearFormat)$prompt"

    if [[ $clearCanvas -eq 1 ]]; then
      clear
    fi

    read -r -sn1 -p "$invalidPrompt" text

    validationResult=
    case $text in
      y|Y|n|N)
        ;;
      *)
        validationResult="Invalid value"
        ;;
    esac
  done

  echo "$text"
}

radioInput -c -p "Agree"

# DESCRIPTION: The entry point for the input functions
# USAGE: crc-input [COMMAND] [ARGUMENTS]
crc-input() {
  local commandToExec
  commandToExec="$1"
  shift

  case $commandToExec in
    text)
        textInput "$@"
      ;;
    select)
        selectInput "$@"
      ;;
    radio)
        radioInput "$@"
      ;;
    *)
        crc-utils die "$(crc-env misuseErrorCode)" "An unknown command crc-input ""$commandToExec"
      ;;
  esac
}

crcInputLoaded=1
